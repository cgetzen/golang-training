# Functions

functions are a great way to organize code into packages, or DRY up a single package.

## Concepts

A gentle introduction:
```go
package main

import "fmt"

func main() {
  sayHi()
  sayHi()
}

func sayHi() {
  fmt.Println("hi")
}
```

functions start with the `func` keyword, are given a name, parenthesis, and then given a block of code.

Functions can also take arguments:
```go
...

func main() {
  sayHi("Larry Sanders")
}

func sayHi(name string) {
  fmt.Println("hi", name)
}
```
Here we can see the identifier (name) comes first, and the type ("string") follows.

You can also have multiple arguments separated by commas:
```go
func sayHi(name string, age int) {
  fmt.Println("Hey", name, "only", (65-age)*365, "days to retirement!")
}
```
If the types are the same, you can remove all but the last identifier:
```go
func sayHi(firstName, middleName, lastName string, age int) {
  ...
}
```

Functions also can have return values:
```go
package main

import "fmt"

func main() {
  fmt.Println(divide(1, 2))
}

func divide(a, b int) float {
  return a / b
}
```

Functions also can have multiple return values. Generally the second return value is an error type.
```go
package main

import (
  "fmt"
  "errors"
)

func main() {
  ans, err := divide(1, 0)
  if err != nil {
    fmt.Println(ans)
  }
}

func divide(a, b int) (int, error) {
  if b == 0 {
    return 0, errors.New("Divide by zero!")
  }
  return a / b, nil
}
```

We look at errors and conditionals in more detail in another section.

They can even have named return values so you don't have to explicitly return values.

```go
...

func divide(a, b int) (answer int, e error) {
  if b == 0 {
    e = errors.New("Divide by zero!") // Note: this is assignment, because it was declared in the function signature
    return
  }
  answer = a / b
  return
}
```

Functions are first class citizens in go - they are a kind of `type`. That means you can nested anonymous functions:

```go
package main
import "fmt"

func main() {
  // An anonymous function that is immediately invoked
  func(a, b int) {
    fmt.Println(a+b)
  }(10, 11) // this is how it is immediately invoked

  // Assigning a variable to an anonymous function
  myFunc := func(a, b int) {
    fmt.Println(a+b)
  }
  myFunc(1, 2)
  myFunc(3, 4)

  // An anonymous func with a return value
  add := func(a, b int) int {
    return a + b
  }
  ans := add(1, 2)
  fmt.Println(ans)

  // You can also create closures
  word := "hello"
  printWord := func() {
    fmt.Println(word)
  }
  printWord()
}
```

## Exercises

## Tips

## Further Reading
