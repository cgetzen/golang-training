# Interfaces

## Concepts

Interfaces allow programmers to decouple software by adhering to the dependency inversion principle.
At a high level, an interface defines a method contract on structs:

```go
package main

import (
    "fmt"
    "strings"
)

type pet interface {
    Sound(int) string
    NumLegs() int
}

type dog struct {}

func (d dog) Sound(length int) string {
    return strings.Repeat("woof ", length)
}

func (d dog) NumLegs() int {
    return 4
}

func Output(p pet) {
    fmt.Printf("He walks on %d legs and makes the sound %s", p.NumLegs(), p.Sound(2))
}

func main() {
    d := dog{}
    Output(d)
}
```

`Output` can be called on `d` because `dog` implements all the methods in the `pet` interface.

Unlike java, go interfaces are implemented implicitly: there is no need to tell the compiler that we want `dog` to adhere to the `pet` interface.

## Exercises

## Tips

## Further Reading
