# Structs

## Concepts

Structs help organize data into groups.

### Definition

Generally, structs are defined at the module level:
```go
package main

type item struct {
    name string
    price int
}

func main() {
    ...
}
```

### Declaration / Assignment

Two ways to declare structs using zero-value initialization:

```go
...

func main() {
    var waffle item
    dogs := item{}
    fmt.Printf("%#+v\n%#+v\n", waffle, dogs) // go doc fmt
}
```

There are two ways to declare a struct while initializing the **fields** of the struct:

```go
...

func main() {
    teddyBear := item{"teddy", 2}
    fidgetSpinner := item{price: 2, name: "spinner"}

    ...
}
```

The first method doesn't use the field names, and the compiler implicitly knows that the field values are in order. If we include the field names, we can declare them in any order.

We can also get and set fields after struct declaration:
```go
...

func main() {
    teddyBear := item{"teddy", 2}
    fmt.Println(teddyBear.price) // get
    teddyBear.price = 3 // set
    fmt.Println(teddyBear.price)
}
```

Nested structures are very common in go:
```go
package main

import "fmt"

type node struct {
    value int
    next *node
}

func main() {
    n1 := node{100, nil}
    n2 := node{}
    n1.next = &n2
    fmt.Printf("%#+v\n%#+v\n", n1, n2)
}
```

We can also use structs in functions:

```go
...

func main() {
    n1 := node{100, nil}
    n2 := node{}
    n2.value = 45
    n1.next = &n2
    fmt.Println(nodeAndChildSum(n1, 2))
}

func nodeAndChildSum(n node, extra int) int {
        return n.value + n.next.value + extra
}
```

Although this is valid go code, it is more common to capture struct related behavior in **methods**:

```go
...

func main() {
    n1 := node{100, nil}
    n2 := node{45, nil}
    n1.next = &n2
    fmt.Println(n1.childSum(2))
}

func (n node) childSum(extra int) int {
    return n.value + n.next.value + extra
}
```

Here we can see `childSum` is defined on `(n node)`, so now you can call x.childSum for any x that has been initialized as a `node`.


TODO: TAKE THE BELOW OUT FOR FURTHER READING
Finally, go supports composition over inheritance TODO: Insert link here.

```go
package main

import "fmt"

type pet struct {
    name string
}

func (p pet) call() string {
    return fmt.Sprintf("Here %s", p.name)
}

type mammal struct {
    age int
    floofLevel int
}

func (m mammal) floof() string {
    switch {
    case m.floofLevel < 5:
        return "lil floof"
    default:
        return "total floofball"
    }
}

type dog struct {
    pet
    mammal
    sound string
}

func main() {
        d := dog{sound: "woof"}
        d.floofLevel = 10
        d.name = "todo"
        fmt.Printf("%s, you %s.\n", d.call(), d.floof())
}
```

Here we can see all the fields from mammal and pet have been **promoted** to the dog struct. Not only this, but you can also use the methods from mammal and pet on dog.

## Exercises

## Tips

## Further Reading
